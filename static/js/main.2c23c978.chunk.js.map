{"version":3,"sources":["logo.svg","utils/history.tsx","spotifyAPI/AuthService.tsx","spotifyAPI/SpotifyAccess.tsx","components/utils/Delayed.tsx","components/DelayedCircularProgress.tsx","components/utils/VirtualizedList.tsx","components/utils/InfiniteLoaderList.tsx","components/Playlists.tsx","utils/PlaylistAlgorithms.tsx","interfaces/Track.tsx","components/utils/CheckboxList.tsx","components/DuplicateTracks.tsx","pages/MainPage.tsx","pages/LoadingPage.tsx","themes/darkTheme.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["module","exports","history","createHashHistory","cookies","Cookies","validateAccessToken","fetchAccessToken","accessToken","get","undefined","Promise","resolve","string","parsed","queryString","parse","window","location","search","access_token","refresh_token","expires_in","rest","searchRest","replaceState","href","replace","consumeSearchParams","stringify","hash","consumeAccessTokenParams","updateTokenCookies","generateNewAccessTokenFromSpotify","refreshAccessToken","refreshToken","console","log","fetch","refresh_token_uri","then","response","json","data","push","backend_uri","set","path","maxAge","expirationTime","minDurationBeforeRefresh","getTracks","playlist","appendTracksFromOffset","offset","tracks","fetchFromSpotifyAPI","id","limit","concat","items","next","checkLikedTracks","appendCheckLikedSongs","liked","ids","leftoverTracks","count","track","length","queryParams","promise","headers","Authorization","processResponse","statusCode","status","all","remove","Delayed","props","useState","hidden","setHidden","useEffect","timeout","setTimeout","wait","clearTimeout","children","DelayedCircularProgress","CircularProgress","size","className","renderRow","content","index","style","item","loaded","isItemLoaded","isLoading","ListItem","height","key","Box","justifyContent","width","display","button","selected","selectedIndex","onClick","onItemClick","ListItemText","primaryTypographyProps","noWrap","primary","getText","VirtualizedList","setSelectedIndex","alreadySelected","onItemSelected","itemData","itemSize","itemCount","onItemsRendered","ref","reff","InfiniteLoaderList","hasNextPage","loadMoreItems","isNextPageLoading","loadNextPage","useStyles","makeStyles","theme","root","minWidth","spacing","margin","backgroundColor","palette","grey","header","color","main","alignItems","paddingLeft","Playlists","classes","playlists","setPlaylists","skippedPlaylists","setSkippedPlaylists","userId","setUserId","setIsNextPageLoading","setHasNextPage","loadMorePlaylistsWithUserId","filteredData","filter","owner","Paper","elevation","Divider","name","onPlaylistSelected","compareTracks","track1","track2","options","sensitivity","artists","localeCompare","getAddedAtDate","Date","added_at","createStyles","CheckboxList","List","map","labelId","role","dense","divider","listItemClassName","handleToggle","ListItemIcon","Checkbox","edge","checked","isChecked","tabIndex","disableRipple","inputProps","getContent","background","default","marginBottom","list","position","listItem","checkedListItem","secondary","paddingRight","title","artist","album","addedAt","duration","DuplicateTracks","setTracks","setChecked","newList","sublist","convert2DListTo1D","duplicates","result","i","bestDuplicateIndex","bestAddedAtTime","now","addedAtTime","getTime","getWorstDuplicates","indexOf","currentIndex","newChecked","splice","Favorite","fontSize","FavoriteBorder","Typography","formatArtists","date","minutesSince","roundedMinutesSince","Math","round","roundedHoursSince","getFullYear","getMonth","slice","getDate","formatAddedAt","durationMs","durationSec","hours","floor","minutes","seconds","formatDuration","duration_ms","Button","variant","startIcon","Delete","newTracks","deleteChecked","app","paddingTop","sideBar","maxWidth","buttonProgress","MainPage","song","setSong","setPlaylist","setDuplicates","findDuplicatesLoading","setFindDuplicatesLoading","setCurrentlyPlayingSong","src","images","url","alt","logo","disabled","duplicateTracks","song1","song2","sortedTracks","sort","currentTrack","currentSong","currentArtist","currentDuplicateList","isFirstDuplicate","j","t","compareTwoStrings","findDuplicateTracks","tracksToCheck","duplicateSet","LoadingPage","darkTheme","createMuiTheme","type","lightBlue","pink","800","900","App","setInterval","accessTokenRefreshInterval","ThemeProvider","CssBaseline","exact","component","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2c23c978.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import { createHashHistory } from \"history\";\r\n\r\nconst history = createHashHistory();\r\nexport default history;\r\n\r\n/**\r\n * Removes the search params not present in the searchRest.\r\n * @param searchRest the rest string of the unconsumed search params\r\n */\r\nexport const consumeSearchParams = (searchRest: string): void => {\r\n  window.history.replaceState(\r\n    null,\r\n    \"\",\r\n    window.location.href.replace(\r\n      window.location.search,\r\n      (searchRest !== \"\" ? \"?\" : \"\") + searchRest\r\n    )\r\n  );\r\n};\r\n","import queryString from \"query-string\";\r\nimport Cookies from \"universal-cookie\";\r\nimport history, { consumeSearchParams } from \"../utils/history\";\r\n\r\nlet accessTokenRefreshInterval = 1; // Minutes\r\nlet minDurationBeforeRefresh = 15; // Minutes\r\nlet expirationTime = 60; // Minutes\r\n\r\nconst overrideUseProductionBackend = true;\r\nconst backend_uri =\r\n  process.env.NODE_ENV === \"production\" || overrideUseProductionBackend\r\n    ? \"https://spotify-u-backend.herokuapp.com\"\r\n    : \"http://localhost:8888\";\r\nlet authentication_uri = backend_uri + \"/login\";\r\nlet refresh_token_uri = backend_uri + \"/refresh_token\";\r\n\r\nlet accessTokenKey = \"access_token\";\r\nlet refreshTokenKey = \"refresh_token\";\r\nlet recentRefreshKey = \"recently_refreshed_access_token\";\r\n\r\nconst cookies = new Cookies();\r\n\r\n/**\r\n * Starts an task to refresh the Spotify access token every 10 minutes;\r\n */\r\nexport const startAccessTokenRefreshInterval = (): void => {\r\n  refreshAccessToken();\r\n  window.setInterval(() => {\r\n    refreshAccessToken();\r\n  }, accessTokenRefreshInterval * 60 * 1000);\r\n};\r\n\r\n/**\r\n * Fetches a new access token from Spotify.\r\n */\r\nexport const validateAccessToken = (): void => {\r\n  fetchAccessToken();\r\n};\r\n\r\n/**\r\n * Returns a promise of an access token if one is found, otherwise generates a new one from Spotify.\r\n *\r\n * Access token search order:\r\n * 1. Cookie\r\n * 2. Parse from address field\r\n * 3. Generate new from Spotify\r\n */\r\nexport const fetchAccessToken = (): Promise<string> | null => {\r\n  // Get from cookie\r\n  let accessToken: string = cookies.get(accessTokenKey);\r\n  if (accessToken !== undefined) {\r\n    return Promise.resolve(accessToken);\r\n  }\r\n\r\n  // Parse from address field\r\n  let parsed = consumeAccessTokenParams();\r\n  accessToken = parsed.access_token;\r\n  if (!isNullOrEmpty(accessToken)) {\r\n    // Add new cookie with the parsed access token\r\n    updateTokenCookies(accessToken, parsed.refresh_token);\r\n    return Promise.resolve(accessToken);\r\n  }\r\n\r\n  // Generate new from Spotify\r\n  generateNewAccessTokenFromSpotify();\r\n  return null;\r\n};\r\n\r\n/**\r\n * Generate new access token from Spotify.\r\n */\r\nexport const invalidateAccessToken = (): void => {\r\n  cookies.remove(accessTokenKey);\r\n  generateNewAccessTokenFromSpotify();\r\n};\r\n\r\n/**\r\n * Refreshes the access token by passing the refresh token to the backend.\r\n * Returns a promise of with the refreshed access token (the same access token\r\n * that the refresh token was originally generated for).\r\n */\r\nexport const refreshAccessToken = (): void => {\r\n  // Don't refresh again if done recently\r\n  if (cookies.get(recentRefreshKey) !== undefined) return;\r\n\r\n  let refreshToken = cookies.get(refreshTokenKey);\r\n  if (refreshToken === undefined) return;\r\n\r\n  console.log(\"Refreshing access token...\");\r\n\r\n  fetch(refresh_token_uri + \"?refresh_token=\" + refreshToken)\r\n    .then((response) => response.json())\r\n    .then((data) => {\r\n      console.log(\"Refreshed access token\");\r\n\r\n      let accessToken = data.access_token;\r\n      updateTokenCookies(accessToken, refreshToken);\r\n    });\r\n};\r\n\r\n/**\r\n * Generates a new access token by redirecting to Spotify's authentication page.\r\n */\r\nfunction generateNewAccessTokenFromSpotify(): void {\r\n  history.push(\"/loading\");\r\n  window.location.replace(authentication_uri);\r\n}\r\n\r\ninterface AccessTokenParams {\r\n  access_token: string;\r\n  expires_in: number;\r\n  refresh_token: string;\r\n}\r\n\r\n/**\r\n * Returns the access token parsed from the address field.\r\n */\r\nfunction consumeAccessTokenParams(): AccessTokenParams {\r\n  let { access_token, refresh_token, expires_in, ...rest } = queryString.parse(\r\n    window.location.search\r\n  );\r\n  consumeSearchParams(queryString.stringify(rest));\r\n  // Remove the hash that is sometimes appended on the callback\r\n  window.location.hash = window.location.hash.replace(\"_=_\", \"\");\r\n  return {\r\n    access_token: access_token as string,\r\n    expires_in: (expires_in as unknown) as number,\r\n    refresh_token: refresh_token as string,\r\n  };\r\n}\r\n\r\n/**\r\n * Updates the access/refresh token values stored in the cookies.\r\n *\r\n * @param accessToken The access token value to set\r\n * @param refreshToken The refresh token value to set\r\n */\r\nfunction updateTokenCookies(accessToken: string, refreshToken: string): void {\r\n  cookies.set(accessTokenKey, accessToken, {\r\n    path: \"/\",\r\n    maxAge: expirationTime * 60,\r\n  });\r\n  cookies.set(refreshTokenKey, refreshToken, {\r\n    path: \"/\",\r\n    maxAge: expirationTime * 60,\r\n  });\r\n  cookies.set(recentRefreshKey, \"\", {\r\n    path: \"/\",\r\n    maxAge: minDurationBeforeRefresh * 60,\r\n  });\r\n}\r\n\r\n/**\r\n * Returns if the specified string is undefined, null or empty.\r\n *\r\n * @param string The string to check\r\n */\r\nfunction isNullOrEmpty(string: string): boolean {\r\n  return string === undefined || string === null || string === \"\";\r\n}\r\n","import { fetchAccessToken, invalidateAccessToken } from \"./AuthService\";\r\nimport queryString from \"query-string\";\r\nimport Playlist from \"../interfaces/Playlist\";\r\nimport Track from \"../interfaces/Track\";\r\n\r\n/**\r\n * Returns the user ID of the current user.\r\n */\r\nexport const getUserId = (): Promise<string | null> => {\r\n  return fetchFromSpotifyAPI(\"me\").then((data) => {\r\n    if (!data) return null;\r\n    return data.id;\r\n  });\r\n};\r\n\r\n/**\r\n * Returns the currently playing song, or null.\r\n */\r\nexport const getSong = (): Promise<string | null> => {\r\n  return fetchFromSpotifyAPI(\"me/player/currently-playing\").then((data) => {\r\n    if (!data || !data.item) return null;\r\n    return data.item.name;\r\n  });\r\n};\r\n\r\n/**\r\n * Returns all tracks from the specified playlist.\r\n *\r\n * @param playlistId The playlist to get the tracks of\r\n */\r\nexport const getTracks = (playlist: Playlist): Promise<Track[] | null> => {\r\n  return appendTracksFromOffset(playlist, 0, []);\r\n};\r\n\r\n/**\r\n * Appends all tracks in the specified playlist, starting from the specified offset, to the specified tracks array.\r\n *\r\n * @param playlist The playlist to get the tracks of\r\n * @param offset The offset to start from\r\n * @param tracks The array to append the tracks to\r\n */\r\nfunction appendTracksFromOffset(\r\n  playlist: Playlist,\r\n  offset: number,\r\n  tracks: Track[]\r\n): Promise<Track[] | null> {\r\n  const limit = 100;\r\n\r\n  return fetchFromSpotifyAPI(`playlists/${playlist.id}/tracks`, {\r\n    limit: limit,\r\n    offset: offset,\r\n  }).then((data: TracksResponse | null) => {\r\n    if (!data) return null;\r\n\r\n    tracks = tracks.concat(data.items);\r\n\r\n    if (!data.next) return Promise.resolve(tracks);\r\n    return appendTracksFromOffset(playlist, offset + limit, tracks);\r\n  });\r\n}\r\n\r\n/**\r\n * Returns a list of booleans representing if each track is liked by the user.\r\n *\r\n * @param tracks The tracks to check if liked\r\n */\r\nexport const checkLikedTracks = (\r\n  tracks: Track[]\r\n): Promise<boolean[] | null> => {\r\n  return appendCheckLikedSongs([], tracks);\r\n};\r\n\r\n/**\r\n * Appends liked track check results to the specified liked array.\r\n *\r\n * @param liked The array to append the results to\r\n * @param tracks The tracks to check\r\n */\r\nfunction appendCheckLikedSongs(\r\n  liked: boolean[],\r\n  tracks: Track[]\r\n): Promise<boolean[] | null> {\r\n  const limit = 50;\r\n\r\n  let ids = \"\";\r\n  let leftoverTracks: Track[] = [];\r\n  let count = 0;\r\n  for (const track of tracks) {\r\n    if (count < limit) {\r\n      if (ids.length !== 0) ids = ids + \",\";\r\n      ids = ids + track.track.id;\r\n    } else leftoverTracks.push(track);\r\n    count++;\r\n  }\r\n\r\n  return fetchFromSpotifyAPI(\"me/tracks/contains\", {\r\n    ids: ids,\r\n  }).then((data: boolean[] | null) => {\r\n    if (!data) return null;\r\n\r\n    liked = liked.concat(data);\r\n\r\n    if (leftoverTracks.length === 0) return Promise.resolve(liked);\r\n    return appendCheckLikedSongs(liked, leftoverTracks);\r\n  });\r\n}\r\n\r\n/**\r\n * The response data when fetching tracks.\r\n */\r\ninterface TracksResponse {\r\n  items: Track[];\r\n  next: string;\r\n}\r\n\r\n/**\r\n * Returns a list of the playlists owned or followed by the Spotify user.\r\n *\r\n * @param limit The maximum number of playlists to return. Default: 20. Minimum: 1. Maximum: 50.\r\n * @param offset The index of the first playlist to return. Default: 0 (the first object).\r\n * Maximum offset: 100.000. Use with limit to get the next set of playlists.\r\n */\r\nexport const getPlaylists = (\r\n  limit?: number,\r\n  offset?: number\r\n): Promise<{ items: Playlist[] } | null> => {\r\n  return fetchFromSpotifyAPI(\"me/playlists\", {\r\n    limit: limit,\r\n    offset: offset,\r\n  }).then((data) => {\r\n    if (!data) return null;\r\n    return data;\r\n  });\r\n};\r\n\r\nfunction fetchFromSpotifyAPI(\r\n  path: string,\r\n  queryParams?: object\r\n): Promise<any | null> {\r\n  let promise = fetchAccessToken();\r\n  if (promise === null) return Promise.resolve(null);\r\n\r\n  return promise\r\n    .then((accessToken) => {\r\n      return fetch(\r\n        \"https://api.spotify.com/v1/\" +\r\n          path +\r\n          (queryParams ? \"?\" + queryString.stringify(queryParams) : \"\"),\r\n        {\r\n          headers: { Authorization: \"Bearer \" + accessToken },\r\n        }\r\n      );\r\n    })\r\n    .then(processResponse);\r\n}\r\n\r\nfunction processResponse(response: {\r\n  status: any;\r\n  json: () => any;\r\n}): Promise<any | null> {\r\n  const statusCode = response.status;\r\n  if (statusCode === 204) return Promise.resolve(null);\r\n  const data = response.json();\r\n  return Promise.all([statusCode, data]).then(([statusCode, data]) => {\r\n    if (statusCode === 401) {\r\n      // Invalid access token\r\n      invalidateAccessToken();\r\n      return null;\r\n    }\r\n\r\n    return statusCode === 200 ? data : null;\r\n  });\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\n\r\ninterface Props {\r\n  wait: number;\r\n}\r\n\r\n/**\r\n * Hides the children until the specified wait (ms) duration is over.\r\n */\r\nconst Delayed: React.FC<Props> = (props) => {\r\n  const [hidden, setHidden] = useState<boolean>(true);\r\n\r\n  useEffect(() => {\r\n    const timeout = setTimeout(() => {\r\n      setHidden(false);\r\n    }, props.wait);\r\n    return () => {\r\n      clearTimeout(timeout);\r\n    };\r\n  }, [props.wait]);\r\n\r\n  return hidden ? null : <>{props.children}</>;\r\n};\r\n\r\nexport default Delayed;\r\n","import React from \"react\";\r\nimport Delayed from \"./utils/Delayed\";\r\nimport CircularProgress from \"@material-ui/core/CircularProgress\";\r\n\r\ninterface Props {\r\n  className?: string;\r\n  size?: number;\r\n  wait?: number;\r\n}\r\n\r\nexport default function DelayedCircularProgress(props: Props) {\r\n  return (\r\n    <Delayed wait={props.wait ? props.wait : 500}>\r\n      <CircularProgress size={props.size} className={props.className} />\r\n    </Delayed>\r\n  );\r\n}\r\n","import React, { useState } from \"react\";\r\nimport \"../../App.scss\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport { FixedSizeList } from \"react-window\";\r\nimport { Box } from \"@material-ui/core\";\r\nimport DelayedCircularProgress from \"../DelayedCircularProgress\";\r\n\r\ninterface RowProps<T> {\r\n  index: number;\r\n  style: React.CSSProperties | undefined;\r\n  data: {\r\n    selectedIndex: number;\r\n    onItemClick: (item: T, index: number) => void;\r\n    items: T[];\r\n    getText: (t: T) => string;\r\n    isLoading?: boolean;\r\n    isItemLoaded?: (index: number) => boolean;\r\n  };\r\n}\r\n\r\nfunction renderRow<T>(props: RowProps<T>) {\r\n  const { index, style } = props;\r\n  const item = props.data.items[index];\r\n\r\n  const loaded: boolean =\r\n    !props.data.isItemLoaded || props.data.isItemLoaded(index);\r\n\r\n  const loading: boolean = !!props.data.isLoading && props.data.isLoading;\r\n\r\n  let content;\r\n  if (loading) {\r\n    content = (\r\n      <ListItem style={{ height: 56 }} key={index}>\r\n        <Box justifyContent=\"center\" width=\"100%\" display=\"flex\">\r\n          <DelayedCircularProgress />\r\n        </Box>\r\n      </ListItem>\r\n    );\r\n  } else if (!loaded) {\r\n    content = null;\r\n  } else {\r\n    content = (\r\n      <ListItem\r\n        button\r\n        key={index}\r\n        selected={props.data.selectedIndex === index}\r\n        onClick={() => {\r\n          if (props.data.onItemClick && item)\r\n            props.data.onItemClick(item, index);\r\n        }}\r\n      >\r\n        <ListItemText\r\n          primaryTypographyProps={{ noWrap: true }}\r\n          primary={props.data.getText(item)}\r\n        />\r\n      </ListItem>\r\n    );\r\n  }\r\n\r\n  return <div style={style}>{content}</div>;\r\n}\r\n\r\ninterface Props<T> {\r\n  height: number;\r\n  itemSize: number;\r\n  items: T[];\r\n  getText: (item: T) => string;\r\n  itemCount?: number;\r\n  onItemSelected?: (item: T, index: number) => void;\r\n  onItemClick?: (item: T, index: number) => void;\r\n  onItemsRendered?: any;\r\n  reff?: any;\r\n  isLoading?: boolean;\r\n  isItemLoaded?: (index: number) => boolean;\r\n}\r\n\r\nfunction VirtualizedList<T>(props: Props<T>) {\r\n  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);\r\n\r\n  const onItemClick = (item: T, index: number) => {\r\n    let alreadySelected = index === selectedIndex;\r\n    setSelectedIndex(index);\r\n    if (props.onItemClick) props.onItemClick(item, index);\r\n    if (!alreadySelected && props.onItemSelected)\r\n      props.onItemSelected(item, index);\r\n  };\r\n\r\n  const data = {\r\n    selectedIndex: selectedIndex,\r\n    onItemClick: onItemClick,\r\n    items: props.items,\r\n    getText: props.getText,\r\n    isLoading: props.isLoading,\r\n    isItemLoaded: props.isItemLoaded,\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <FixedSizeList\r\n        itemData={data}\r\n        height={props.height}\r\n        width={\"100%\"}\r\n        itemSize={props.itemSize}\r\n        itemCount={props.itemCount ? props.itemCount : data.items.length}\r\n        onItemsRendered={props.onItemsRendered}\r\n        ref={props.reff}\r\n      >\r\n        {renderRow}\r\n      </FixedSizeList>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default VirtualizedList;\r\n","import React from \"react\";\r\nimport VirtualizedList from \"./VirtualizedList\";\r\nimport InfiniteLoader from \"react-window-infinite-loader\";\r\n\r\ninterface Props<T> {\r\n  height: number;\r\n  itemSize: number;\r\n  hasNextPage: boolean;\r\n  isNextPageLoading: boolean;\r\n  items: T[];\r\n  getText: (item: T) => string;\r\n  loadNextPage: (index: number) => Promise<any>;\r\n  onItemSelected?: (item: T, index: number) => void;\r\n  onItemClick?: (item: T, index: number) => void;\r\n}\r\n\r\nfunction InfiniteLoaderList<T>(props: Props<T>) {\r\n  // If there are more items to be loaded, add an extra row to hold a loading indicator.\r\n  const itemCount = props.hasNextPage\r\n    ? props.items.length + 1\r\n    : props.items.length;\r\n\r\n  // Only load 1 page of items at a time.\r\n  const loadMoreItems = props.isNextPageLoading\r\n    ? () => Promise.resolve()\r\n    : props.loadNextPage;\r\n\r\n  // Every row is loaded except for the loading indicator row.\r\n  const isItemLoaded = (index: number) =>\r\n    !props.hasNextPage || index < props.items.length;\r\n\r\n  function getText(item: T): string {\r\n    return props.getText(item);\r\n  }\r\n\r\n  return (\r\n    <InfiniteLoader\r\n      isItemLoaded={isItemLoaded}\r\n      itemCount={itemCount}\r\n      loadMoreItems={loadMoreItems}\r\n    >\r\n      {({ onItemsRendered, ref }) => (\r\n        <VirtualizedList\r\n          isLoading={props.isNextPageLoading}\r\n          isItemLoaded={isItemLoaded}\r\n          onItemsRendered={onItemsRendered}\r\n          reff={ref}\r\n          height={props.height}\r\n          itemSize={props.itemSize}\r\n          items={props.items}\r\n          itemCount={itemCount}\r\n          getText={getText}\r\n          onItemSelected={props.onItemSelected}\r\n          onItemClick={props.onItemClick}\r\n        />\r\n      )}\r\n    </InfiniteLoader>\r\n  );\r\n}\r\n\r\nexport default InfiniteLoaderList;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { getPlaylists, getUserId } from \"../spotifyAPI/SpotifyAccess\";\r\nimport \"../App.scss\";\r\nimport InfiniteLoaderList from \"./utils/InfiniteLoaderList\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport Playlist from \"../interfaces/Playlist\";\r\nimport { Divider } from \"@material-ui/core\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    minWidth: theme.spacing(22),\r\n    margin: theme.spacing(3),\r\n    backgroundColor: theme.palette.grey[900],\r\n  },\r\n  header: {\r\n    color: theme.palette.primary.main,\r\n    display: \"flex\",\r\n    alignItems: \"center\",\r\n    paddingLeft: theme.spacing(2),\r\n    height: theme.spacing(6),\r\n  },\r\n}));\r\n\r\ninterface Props {\r\n  onPlaylistSelected?: (playlist: Playlist, index: number) => void;\r\n}\r\n\r\nconst Playlists: React.FC<Props> = (props) => {\r\n  const classes = useStyles();\r\n  const [playlists, setPlaylists] = useState<Playlist[]>([]);\r\n  const [skippedPlaylists, setSkippedPlaylists] = useState<number>(0);\r\n  const [userId, setUserId] = useState<string | null>(null);\r\n  const [isNextPageLoading, setIsNextPageLoading] = useState<boolean>(false);\r\n  const [hasNextPage, setHasNextPage] = useState<boolean>(true);\r\n\r\n  useEffect(() => {\r\n    getUserId().then((userId) => {\r\n      loadMorePlaylistsWithUserId(userId, 0);\r\n      setUserId(userId);\r\n    });\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const loadMorePlaylists = (index: number): Promise<any> => {\r\n    return loadMorePlaylistsWithUserId(userId, index);\r\n  };\r\n\r\n  const loadMorePlaylistsWithUserId = (\r\n    userId: string | null,\r\n    index: number\r\n  ): Promise<any> => {\r\n    if (!userId) return Promise.resolve();\r\n\r\n    setIsNextPageLoading(true);\r\n    let loadAmount = 40;\r\n\r\n    return getPlaylists(loadAmount, index + skippedPlaylists).then((data) => {\r\n      setIsNextPageLoading(false);\r\n\r\n      if (!data) {\r\n        setHasNextPage(false);\r\n        return;\r\n      }\r\n\r\n      if (data.items.length < loadAmount) setHasNextPage(false);\r\n\r\n      // Filter out unowned playlists\r\n      let filteredData = data.items.filter(\r\n        (playlist) => playlist.owner.id === userId\r\n      );\r\n\r\n      setSkippedPlaylists(\r\n        skippedPlaylists + data.items.length - filteredData.length // Count unowned playlists\r\n      );\r\n      setPlaylists(\r\n        (playlists) => playlists.concat(filteredData) // Append loaded playlists\r\n      );\r\n    });\r\n  };\r\n\r\n  return (\r\n    <Paper elevation={3} className={classes.root}>\r\n      <div className={classes.header}>\r\n        <h2>Playlists</h2>\r\n      </div>\r\n      <Divider />\r\n      <InfiniteLoaderList\r\n        hasNextPage={hasNextPage}\r\n        isNextPageLoading={isNextPageLoading}\r\n        height={784}\r\n        itemSize={46}\r\n        items={playlists}\r\n        getText={(playlist: Playlist) => playlist.name}\r\n        loadNextPage={loadMorePlaylists}\r\n        onItemSelected={props.onPlaylistSelected}\r\n      />\r\n    </Paper>\r\n  );\r\n};\r\n\r\nexport default Playlists;\r\n","import Track from \"../interfaces/Track\";\r\nimport { compareTwoStrings } from \"string-similarity\";\r\n\r\n/**\r\n * Looks through the specified list of tracks and returns any duplicates.\r\n *\r\n * @param tracks The tracks to look through\r\n */\r\nexport const findDuplicateTracks = (tracks: Track[]): Track[][] => {\r\n  // Create a copy of the array sorted by artist\r\n  let sortedTracks: (Track | null)[] = tracks.slice().sort(compareTracks);\r\n  let duplicates: Track[][] = [];\r\n\r\n  // Loop through the whole list\r\n  for (let i = 0; i < sortedTracks.length; i++) {\r\n    let currentTrack = sortedTracks[i];\r\n    // If already checked, go to the next track\r\n    if (!currentTrack) continue;\r\n\r\n    // Store the current song and artist\r\n    let currentSong = currentTrack.track.name;\r\n    let currentArtist = currentTrack.track.artists[0].name;\r\n    // List of duplicates of the current track\r\n    let currentDuplicateList = [];\r\n\r\n    let isFirstDuplicate: boolean = true;\r\n    // Loop through all subsequent tracks by the current artist\r\n    for (let j = i + 1; j < sortedTracks.length; j++) {\r\n      let t = sortedTracks[j];\r\n      // If already checked, go to the next track\r\n      if (!t) continue;\r\n      // If reached the next artist, break\r\n      if (t.track.artists[0].name !== currentArtist) break;\r\n\r\n      // If found duplicate, add it to the results list\r\n      if (isSameSong(t.track.name, currentSong)) {\r\n        // Make sure the current track is added once\r\n        if (isFirstDuplicate) {\r\n          isFirstDuplicate = false;\r\n          currentDuplicateList.push(currentTrack);\r\n        }\r\n        currentDuplicateList.push(t);\r\n        // Remove track from list to avoid checking it again\r\n        sortedTracks[j] = null;\r\n      }\r\n    }\r\n\r\n    // If a set of duplicates was found, add that set to the result list\r\n    if (currentDuplicateList.length > 0) duplicates.push(currentDuplicateList);\r\n  }\r\n  return duplicates;\r\n};\r\n\r\n/**\r\n * Compare-function for sorting tracks by artist, then title.\r\n */\r\nfunction compareTracks(track1: Track, track2: Track): number {\r\n  let locale = \"en\";\r\n  let options = { sensitivity: \"base\" };\r\n  return (\r\n    2 *\r\n      track1.track.artists[0].name.localeCompare(\r\n        track2.track.artists[0].name,\r\n        locale,\r\n        options\r\n      ) +\r\n    1 * track1.track.name.localeCompare(track2.track.name, locale, options)\r\n  );\r\n}\r\n\r\n/**\r\n * Returns if the specified song names are similar enough to be interpreted as the same track.\r\n */\r\nfunction isSameSong(song1: string, song2: string) {\r\n  return compareTwoStrings(song1, song2) >= 0.8;\r\n}\r\n","export default interface Track {\r\n  added_at: string;\r\n  track: Info;\r\n  liked: boolean | undefined;\r\n}\r\n\r\ninterface Info {\r\n  name: string;\r\n  id: string;\r\n  artists: Artist[];\r\n  album: Album;\r\n  duration_ms: number;\r\n  uri: string;\r\n}\r\n\r\ninterface Artist {\r\n  name: string;\r\n  id: string;\r\n}\r\n\r\ninterface Album {\r\n  name: string;\r\n}\r\n\r\nexport const getAddedAtDate = (track: Track): Date => {\r\n  return new Date(Date.parse(track.added_at));\r\n};\r\n","import React from \"react\";\r\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\r\nimport Checkbox from \"@material-ui/core/Checkbox\";\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n  createStyles({\r\n    root: {\r\n      width: \"100%\",\r\n    },\r\n  })\r\n);\r\n\r\ninterface Props<T> {\r\n  items: T[];\r\n  isChecked: (index: number) => boolean;\r\n  handleToggle: (index: number) => void;\r\n  getContent: (item: T) => JSX.Element;\r\n  listItemClassName?: (index: number) => string;\r\n}\r\n\r\nexport default function CheckboxList<T>(props: Props<T>) {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <List className={classes.root}>\r\n      {props.items.map((item, index) => {\r\n        const labelId = `checkbox-list-label-${index}`;\r\n\r\n        return (\r\n          <ListItem\r\n            key={index}\r\n            role={undefined}\r\n            dense\r\n            button\r\n            divider\r\n            className={\r\n              props.listItemClassName && props.listItemClassName(index)\r\n            }\r\n            onClick={() => props.handleToggle(index)}\r\n          >\r\n            <ListItemIcon>\r\n              <Checkbox\r\n                edge=\"start\"\r\n                checked={props.isChecked(index)}\r\n                tabIndex={-1}\r\n                disableRipple\r\n                inputProps={{ \"aria-labelledby\": labelId }}\r\n              />\r\n            </ListItemIcon>\r\n            {props.getContent(item)}\r\n          </ListItem>\r\n        );\r\n      })}\r\n    </List>\r\n  );\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\";\r\nimport { Button, Typography, Divider } from \"@material-ui/core\";\r\nimport { Delete, Favorite, FavoriteBorder } from \"@material-ui/icons\";\r\nimport Track, { getAddedAtDate } from \"../interfaces/Track\";\r\nimport CheckboxList from \"../components/utils/CheckboxList\";\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n  createStyles({\r\n    root: {\r\n      backgroundColor: theme.palette.background.default,\r\n    },\r\n    header: {\r\n      color: theme.palette.primary.main,\r\n      display: \"flex\",\r\n      alignItems: \"center\",\r\n      paddingLeft: theme.spacing(2),\r\n      height: theme.spacing(6),\r\n    },\r\n    button: {\r\n      margin: theme.spacing(1),\r\n      marginBottom: theme.spacing(10),\r\n    },\r\n    list: {\r\n      position: \"relative\",\r\n      //overflow: \"auto\",\r\n      //maxHeight: 600,\r\n      width: \"100%\",\r\n    },\r\n    listItem: {\r\n      width: \"100%\",\r\n      display: \"flex\",\r\n      alignItems: \"center\",\r\n    },\r\n    checkedListItem: {\r\n      backgroundColor: theme.palette.secondary.main + \"08\",\r\n    },\r\n    liked: {\r\n      width: \"3%\",\r\n      display: \"flex\",\r\n      alignItems: \"center\",\r\n      minWidth: theme.spacing(5),\r\n      paddingRight: theme.spacing(2),\r\n    },\r\n    title: {\r\n      width: \"37%\",\r\n      minWidth: theme.spacing(20),\r\n      paddingRight: theme.spacing(2),\r\n    },\r\n    artist: {\r\n      width: \"25%\",\r\n      minWidth: theme.spacing(15),\r\n      paddingRight: theme.spacing(2),\r\n    },\r\n    album: {\r\n      width: \"20%\",\r\n      minWidth: theme.spacing(15),\r\n      paddingRight: theme.spacing(2),\r\n    },\r\n    addedAt: {\r\n      width: \"10%\",\r\n      minWidth: theme.spacing(13),\r\n      paddingRight: theme.spacing(2),\r\n    },\r\n    duration: {\r\n      width: \"5%\",\r\n      minWidth: theme.spacing(5),\r\n      display: \"flex\",\r\n      justifyContent: \"flex-end\",\r\n    },\r\n  })\r\n);\r\n\r\n/**\r\n * Returns the index of the newest added track from each duplicate set.\r\n *\r\n * @param duplicates The sets of duplicates to check\r\n */\r\nfunction getWorstDuplicates(duplicates: Track[][]): number[] {\r\n  let result: number[] = [];\r\n\r\n  let i = 0;\r\n  for (const tracks of duplicates) {\r\n    let bestDuplicateIndex = -1;\r\n    let bestAddedAtTime: number = Date.now();\r\n\r\n    for (const track of tracks) {\r\n      let addedAtTime = getAddedAtDate(track).getTime();\r\n\r\n      if (bestDuplicateIndex < 0) {\r\n        bestDuplicateIndex = i;\r\n        bestAddedAtTime = addedAtTime;\r\n      } else if (addedAtTime < bestAddedAtTime) {\r\n        result.push(bestDuplicateIndex);\r\n        bestDuplicateIndex = i;\r\n        bestAddedAtTime = addedAtTime;\r\n      } else {\r\n        result.push(i);\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Returns a one-dimensional expanded version of a 2D list.\r\n *\r\n * @param list The list to get a 1D version of\r\n */\r\nfunction convert2DListTo1D<T>(list: T[][]): T[] {\r\n  let newList: T[] = [];\r\n  for (const sublist of list) {\r\n    newList.push(...sublist);\r\n  }\r\n  return newList;\r\n}\r\n\r\n/**\r\n * Formats the artists string.\r\n * Returns just the artist name if one, otherwise a list of the artists separated with \", \".\r\n *\r\n * @param track The track to get the artists from\r\n */\r\nfunction formatArtists(track: Track): string {\r\n  let result: string = \"\";\r\n  for (const artist of track.track.artists) {\r\n    if (result.length !== 0) result = result + \", \";\r\n    result = result + artist.name;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Formats the \"added at\" date like Spotify does.\r\n * Shows how many minutes/hours/days ago if recent, otherwise the full date.\r\n *\r\n * @param date The date that the track was added at\r\n */\r\nfunction formatAddedAt(date: Date): string {\r\n  let minutesSince = (Date.now() - date.getTime()) / (1000 * 60);\r\n  let roundedMinutesSince = Math.round(minutesSince);\r\n  if (roundedMinutesSince === 1) return \"a minute ago\";\r\n  if (roundedMinutesSince < 60) return roundedMinutesSince + \" minutes ago\";\r\n  let roundedHoursSince = Math.round(minutesSince / 60);\r\n  if (roundedHoursSince === 1) return \"an hour ago\";\r\n  if (roundedHoursSince < 24) return roundedHoursSince + \" hours ago\";\r\n\r\n  return (\r\n    date.getFullYear() +\r\n    \"-\" +\r\n    (\"0\" + (date.getMonth() + 1)).slice(-2) +\r\n    \"-\" +\r\n    (\"0\" + date.getDate()).slice(-2)\r\n  );\r\n}\r\n\r\n/**\r\n * Formats the song duration.\r\n *\r\n * @param durationMs The duration of the song in milliseconds\r\n */\r\nfunction formatDuration(durationMs: number): string {\r\n  let durationSec = Math.round(durationMs / 1000);\r\n  let hours = Math.floor(durationSec / (60 * 60));\r\n  let minutes = Math.floor((durationSec - hours * 3600) / 60);\r\n  let seconds = durationSec - hours * 3600 - minutes * 60;\r\n\r\n  let minutesString = (hours > 0 && minutes < 10 ? \"0\" : \"\") + minutes;\r\n  let secondsString = (seconds < 10 ? \"0\" : \"\") + seconds;\r\n\r\n  return (hours > 0 ? hours + \":\" : \"\") + minutesString + \":\" + secondsString;\r\n}\r\n\r\ninterface Props {\r\n  duplicates: Track[][];\r\n}\r\n\r\n/**\r\n * List of duplicate tracks that can be removed.\r\n */\r\nconst DuplicateTracks: React.FC<Props> = (props) => {\r\n  const classes = useStyles();\r\n  const [tracks, setTracks] = useState<Track[]>([]);\r\n  const [checked, setChecked] = useState<number[]>([]);\r\n\r\n  useEffect(() => {\r\n    setTracks(convert2DListTo1D(props.duplicates));\r\n    setChecked(getWorstDuplicates(props.duplicates));\r\n  }, [props.duplicates]);\r\n\r\n  const isChecked = (index: number): boolean => {\r\n    return checked.indexOf(index) !== -1;\r\n  };\r\n\r\n  const handleToggle = (index: number) => {\r\n    const currentIndex = checked.indexOf(index);\r\n    const newChecked = [...checked];\r\n\r\n    if (currentIndex === -1) {\r\n      newChecked.push(index);\r\n    } else {\r\n      newChecked.splice(currentIndex, 1);\r\n    }\r\n\r\n    setChecked(newChecked);\r\n  };\r\n\r\n  const deleteChecked = () => {\r\n    let newTracks: Track[] = [];\r\n\r\n    for (let i = 0; i < tracks.length; i++) {\r\n      let track = tracks[i];\r\n\r\n      if (isChecked(i)) {\r\n        //TODO: remove the track with SpotifyAPI\r\n      } else {\r\n        newTracks.push(track);\r\n      }\r\n      setChecked([]);\r\n      setTracks(newTracks);\r\n    }\r\n\r\n    for (const index of checked) {\r\n      console.log(\"Delete \" + tracks[index].track.name);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <div className={classes.header}>\r\n        <h2>Found {props.duplicates.length} songs with duplicates:</h2>\r\n      </div>\r\n      <Divider />\r\n      <div className={classes.list}>\r\n        <CheckboxList<Track>\r\n          items={tracks}\r\n          isChecked={(index) => isChecked(index)}\r\n          handleToggle={handleToggle}\r\n          listItemClassName={(index) =>\r\n            isChecked(index) ? classes.checkedListItem : \"\"\r\n          }\r\n          getContent={(item) => (\r\n            <div className={classes.listItem}>\r\n              <div className={classes.liked}>\r\n                {item.liked ? (\r\n                  <Favorite fontSize=\"small\" />\r\n                ) : (\r\n                  <FavoriteBorder fontSize=\"small\" />\r\n                )}\r\n              </div>\r\n              <div className={classes.title}>\r\n                <Typography noWrap>{item.track.name}</Typography>\r\n              </div>\r\n              <div className={classes.artist}>\r\n                <Typography noWrap>{formatArtists(item)}</Typography>\r\n              </div>\r\n              <div className={classes.album}>\r\n                <Typography noWrap>{item.track.album.name}</Typography>\r\n              </div>\r\n              <div className={classes.addedAt}>\r\n                <Typography noWrap>\r\n                  {formatAddedAt(getAddedAtDate(item))}\r\n                </Typography>\r\n              </div>\r\n              <div className={classes.duration}>\r\n                <Typography noWrap>\r\n                  {formatDuration(item.track.duration_ms)}\r\n                </Typography>\r\n              </div>\r\n            </div>\r\n          )}\r\n        />\r\n      </div>\r\n      <div>\r\n        <Button\r\n          color=\"secondary\"\r\n          variant=\"contained\"\r\n          className={classes.button}\r\n          startIcon={<Delete />}\r\n          onClick={() => deleteChecked()}\r\n        >\r\n          Delete ({checked.length})\r\n        </Button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DuplicateTracks;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport {\r\n  getSong,\r\n  getTracks,\r\n  checkLikedTracks,\r\n} from \"../spotifyAPI/SpotifyAccess\";\r\nimport logo from \"../logo.svg\";\r\nimport \"../App.scss\";\r\nimport { Button } from \"@material-ui/core\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Divider from \"@material-ui/core/Divider\";\r\nimport Playlist from \"../interfaces/Playlist\";\r\nimport Track from \"../interfaces/Track\";\r\nimport Playlists from \"../components/Playlists\";\r\nimport { findDuplicateTracks } from \"../utils/PlaylistAlgorithms\";\r\nimport DuplicateTracks from \"../components/DuplicateTracks\";\r\nimport DelayedCircularProgress from \"../components/DelayedCircularProgress\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    display: \"flex\",\r\n  },\r\n  app: {\r\n    width: \"100%\",\r\n    justifyContent: \"center\",\r\n  },\r\n  header: {\r\n    width: \"100%\",\r\n    justifyContent: \"center\",\r\n    paddingTop: theme.spacing(3),\r\n  },\r\n  content: {\r\n    paddingTop: theme.spacing(3),\r\n  },\r\n  sideBar: {\r\n    width: \"100%\",\r\n    maxWidth: theme.spacing(40),\r\n  },\r\n  buttonProgress: {\r\n    position: \"absolute\",\r\n  },\r\n  button: {\r\n    margin: theme.spacing(1),\r\n  },\r\n}));\r\n\r\nconst MainPage: React.FC = () => {\r\n  const classes = useStyles();\r\n  const [song, setSong] = useState<string | null>(null);\r\n  const [playlist, setPlaylist] = useState<Playlist | null>(null);\r\n  const [duplicates, setDuplicates] = useState<Track[][] | null>(null);\r\n  const [findDuplicatesLoading, setFindDuplicatesLoading] = useState<boolean>(\r\n    false\r\n  );\r\n\r\n  useEffect(() => {\r\n    setCurrentlyPlayingSong();\r\n  }, []);\r\n\r\n  const setCurrentlyPlayingSong = (): void => {\r\n    getSong().then((result) => {\r\n      setSong(result);\r\n    });\r\n  };\r\n\r\n  const onClickFindDuplicates = () => {\r\n    if (!playlist) return;\r\n\r\n    setFindDuplicatesLoading(true);\r\n    getTracks(playlist).then((data) => {\r\n      if (!data) {\r\n        setFindDuplicatesLoading(false);\r\n        return;\r\n      }\r\n      let duplicateTracks: Track[][] = findDuplicateTracks(data);\r\n      let tracksToCheck: Track[] = [];\r\n      for (const duplicateSet of duplicateTracks) {\r\n        for (const t of duplicateSet) {\r\n          tracksToCheck.push(t);\r\n        }\r\n      }\r\n      checkLikedTracks(tracksToCheck).then((data) => {\r\n        setFindDuplicatesLoading(false);\r\n        if (!data) return;\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n          tracksToCheck[i].liked = data[i];\r\n        }\r\n\r\n        setDuplicates(duplicateTracks);\r\n      });\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <div className={classes.sideBar}>\r\n        <Playlists\r\n          onPlaylistSelected={(playlist, index) => {\r\n            setPlaylist(playlist);\r\n            setDuplicates(null);\r\n          }}\r\n        />\r\n      </div>\r\n\r\n      <div className={classes.app}>\r\n        {playlist ? (\r\n          <div>\r\n            <div className={classes.header}>\r\n              {playlist ? (\r\n                <div>\r\n                  <img\r\n                    height={300}\r\n                    src={playlist.images[0].url}\r\n                    alt={\"Playlist Cover\"}\r\n                  />\r\n                  <h1>{playlist.name}</h1>\r\n                </div>\r\n              ) : (\r\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n              )}\r\n              <p />\r\n            </div>\r\n\r\n            <Divider variant=\"middle\" />\r\n\r\n            <div className={classes.content}>\r\n              <Button\r\n                color=\"primary\"\r\n                variant=\"outlined\"\r\n                className={classes.button}\r\n                onClick={setCurrentlyPlayingSong}\r\n              >\r\n                Show Current Song\r\n              </Button>\r\n              <Button\r\n                color=\"primary\"\r\n                variant=\"contained\"\r\n                disabled={findDuplicatesLoading}\r\n                className={classes.button}\r\n                onClick={onClickFindDuplicates}\r\n              >\r\n                Find Duplicate Songs\r\n                {findDuplicatesLoading && (\r\n                  <DelayedCircularProgress\r\n                    className={classes.buttonProgress}\r\n                    size={24}\r\n                    wait={300}\r\n                  />\r\n                )}\r\n              </Button>\r\n              <Button\r\n                color=\"primary\"\r\n                variant=\"outlined\"\r\n                className={classes.button}\r\n                onClick={() => console.log(playlist)}\r\n              >\r\n                Print Playlist\r\n              </Button>\r\n              <Button\r\n                color=\"primary\"\r\n                variant=\"outlined\"\r\n                className={classes.button}\r\n                onClick={() =>\r\n                  getTracks(playlist).then((data) => console.log(data))\r\n                }\r\n              >\r\n                Print Tracks\r\n              </Button>\r\n\r\n              <h1>{song ? song : \"-No song is currently playing-\"}</h1>\r\n              <div>\r\n                {duplicates ? (\r\n                  <DuplicateTracks duplicates={duplicates} />\r\n                ) : null}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        ) : (\r\n          <div className={classes.header}>\r\n            <h1>Select a playlist</h1>\r\n          </div>\r\n        )}\r\n      </div>\r\n      <div className={classes.sideBar} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MainPage;\r\n","import React from \"react\";\r\nimport logo from \"../logo.svg\";\r\nimport \"../App.scss\";\r\n\r\nconst LoadingPage: React.FC = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n      <h1>Loading...</h1>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default LoadingPage;\r\n","import { createMuiTheme } from \"@material-ui/core/styles\";\r\nimport { lightBlue, pink } from \"@material-ui/core/colors\";\r\n\r\nlet darkGrey = \"#121212\";\r\nlet mediumGrey = \"#181818\";\r\nlet lightGrey = \"#282828\";\r\n\r\nconst darkTheme = createMuiTheme({\r\n  palette: {\r\n    type: \"dark\",\r\n    background: {\r\n      default: mediumGrey,\r\n    },\r\n    primary: lightBlue,\r\n    secondary: pink,\r\n    grey: {\r\n      800: lightGrey,\r\n      900: darkGrey,\r\n    },\r\n  },\r\n});\r\n\r\nexport default darkTheme;\r\n","import React from \"react\";\nimport MainPage from \"./pages/MainPage\";\nimport LoadingPage from \"./pages/LoadingPage\";\nimport {\n  validateAccessToken,\n  startAccessTokenRefreshInterval,\n} from \"./spotifyAPI/AuthService\";\nimport { Router, Switch, Route } from \"react-router-dom\";\nimport \"./App.scss\";\nimport history from \"./utils/history\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { ThemeProvider } from \"@material-ui/core/styles\";\nimport darkTheme from \"./themes/darkTheme\";\n\nfunction App() {\n  validateAccessToken();\n  startAccessTokenRefreshInterval();\n\n  return (\n    <div className=\"outerWrap\">\n      <ThemeProvider theme={darkTheme}>\n        <CssBaseline />\n        <Router history={history}>\n          <div className=\"App\">\n            <Switch>\n              <Route path=\"/\" exact component={MainPage} />\n              <Route path=\"/loading\" exact component={LoadingPage} />\n              <Route\n                path=\"/auth\"\n                exact\n                component={() => {\n                  validateAccessToken();\n                  return null;\n                }}\n              />\n            </Switch>\n          </div>\n        </Router>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}